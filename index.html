<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>待ち行列シミュレーション (視覚化UI)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Interフォントの設定 */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f7f7;
            padding: 20px;
        }

        /* カスタムスタイル */
        .container {
            display: flex;
            flex-direction: column;
            max-width: 1200px;
            margin: 0 auto;
            gap: 20px;
        }

        .setting-card, .visualization-card {
            background-color: white;
            padding: 24px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
        }

        .visualization-card {
            min-height: 400px;
            overflow: hidden;
            position: relative;
        }

        .simulation-area {
            display: flex;
            flex-direction: column;
            gap: 10px;
            height: 100%;
        }

        /* 乗り場（サービス提供者）のスタイル */
        .service-point-container {
            display: flex;
            gap: 40px; 
            margin-bottom: 20px;
            align-items: flex-start; 
            padding-left: 20px; 
        }

        .service-point-wrap {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .service-point {
            width: 150px; 
            height: 100px; 
            background-color: #3B82F6; 
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            position: relative;
            overflow: hidden;
            box-shadow: 0 6px 15px rgba(59, 130, 246, 0.5);
            transition: background-color 0.3s ease;
        }

        /* 乗車時間ゲージのスタイル */
        .service-point .gauge-area {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 4px;
            background-color: rgba(0, 0, 0, 0.2);
        }

        .service-point .progress-bar {
            height: 10px; 
            background-color: #FBBF24; 
            width: 0%;
            transition: width 0.1s linear;
            border-radius: 5px;
        }
        
        /* 待ち行列のスタイル - 乗り場へ向かうレーン */
        .queue-flow-container {
            position: relative;
            display: flex;
            align-items: center;
            height: 60px; 
            margin-top: 10px;
            margin-bottom: 20px;
        }
        
        .queue-line {
            position: absolute;
            left: 170px; 
            right: 20px; 
            height: 20px;
            background-color: #D1D5DB; 
            border-radius: 10px;
            display: flex;
            align-items: center;
        }
        
        /* キューの乗車待機エリア (先頭) */
        .queue-entrance {
            position: absolute;
            top: -10px;
            left: 140px; 
            width: 30px;
            height: 40px;
            border-left: 4px dashed #FBBF24; 
            z-index: 5;
        }

        /* 客（生徒）のスタイル */
        .person {
            width: 45px; 
            height: 45px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 18px;
            font-weight: bold;
            position: absolute;
            /* 動きを単純化するため、transformとopacityのみをtransition対象にする */
            transition: transform 0.4s ease-out; 
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
            z-index: 10;
            top: 50%;
            transform: translateY(-50%) translateX(0); 
            opacity: 0; /* ★修正点: 初期状態では非表示 */
        }

        .person.waiting {
            background-color: #FBBF24; 
            opacity: 1; 
        }
        
        /* 客のリアルタイム待ち時間表示のスタイル */
        .person .person-info {
            position: absolute;
            width: 120px; /* 少し幅を広げる */
            text-align: center;
            bottom: -20px; 
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
            font-size: 10px; 
            font-weight: normal;
        }
        
        /* 待ち時間表示の色分け */
        .person .wait-time.text-green-600 {
            color: #059669;
            font-weight: bold;
        }
        .person .wait-time.text-red-500 {
            color: #EF4444;
            font-weight: bold;
        }
        
        /* 乗り場内の客のスタイル (改善) */
        .sp-person-container {
            position: absolute; 
            bottom: 5px; 
            right: 5px; 
            width: 45px; 
            height: auto; 
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 0.3s ease;
        }
        
        .sp-person-number {
            width: 40px; 
            height: 40px; 
            font-size: 18px; 
            font-weight: bold;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: white; 
            color: #3B82F6; 
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .sp-wait-time {
            font-size: 12px; /* 少し大きく */
            font-weight: bold;
            color: white; 
            margin-top: 2px;
            text-shadow: 0 0 2px rgba(0, 0, 0, 0.5); 
            white-space: nowrap;
        }
        /* 乗車中の長い待ち時間に対する視覚的警告 */
        .sp-wait-time.text-yellow-400 {
            color: #FBBF24;
            text-shadow: 0 0 4px rgba(0, 0, 0, 0.9); 
        }


        .status-bar {
            background-color: #E5E7EB; 
            padding: 12px;
            border-radius: 8px;
            margin-top: 20px;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 16px;
        }
        
        /* 現在時刻の強調スタイル */
        #currentTimeDisplayWrapper {
            grid-column: span 1; 
        }
        #currentTime {
            font-size: 1.875rem; 
            font-weight: 800; 
            color: #1D4ED8; 
            display: block;
            line-height: 1.1;
        }
        #currentTimeLabel {
            font-size: 0.875rem; 
            color: #4B5563; 
        }

        /* その他の統計情報 */
        .status-bar > div:not(#currentTimeDisplayWrapper) {
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        .status-bar > div:not(#currentTimeDisplayWrapper) span {
            font-size: 1.25rem; 
            font-weight: 700; 
        }

        /* スライダーの見た目を調整 */
        .speed-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #EF4444; 
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
        }

        .speed-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #EF4444;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
        }

        /* 待ち時間一覧表示用スタイル */
        #waitingTimesListContainer {
            max-height: 250px;
            overflow-y: auto;
            padding: 10px;
            background-color: #F9FAFB; 
            border-radius: 8px;
            margin-top: 20px;
            border: 1px solid #E5E7EB;
        }
        
        .wait-list-item {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            border-bottom: 1px dashed #D1D5DB;
            font-size: 0.875rem; 
        }
        .wait-list-item:last-child {
            border-bottom: none;
        }
        .wait-list-label {
            color: #4B5563; 
        }
        .wait-list-value {
            font-weight: 600;
            color: #1F2937; 
        }
        .wait-list-value.text-red-500 {
            color: #EF4444;
        }
        .wait-list-value.text-green-600 {
            color: #059669;
        }
    </style>
</head>
<body>

<div class="container">
    <header class="text-center">
        <h1 class="text-3xl font-extrabold text-gray-800 mb-2">待ち行列シミュレーション (アトラクション乗車)</h1>
    </header>

    <!-- 設定カード -->
    <div class="setting-card">
        <h2 class="text-xl font-semibold mb-4 text-gray-700">シミュレーション設定</h2>
        <div class="grid grid-cols-1 md:grid-cols-3 gap-6">

            <!-- 乗り場数選択 -->
            <div class="flex flex-col">
                <label for="servicePoints" class="font-medium mb-1 text-gray-600">乗り場/サービス数</label>
                <select id="servicePoints" class="p-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500">
                    <option value="1">乗り場 1つ</option>
                    <option value="2">乗り場 2つ</option>
                </select>
            </div>

            <!-- 最大到着間隔 -->
            <div class="flex flex-col">
                <label for="maxArrivalInterval" class="font-medium mb-1 text-gray-600">最大到着間隔 (秒)</label>
                <input type="number" id="maxArrivalInterval" value="120" min="10" class="p-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500">
                <p class="text-xs text-gray-400 mt-1">客の到着間隔は 1〜この値の乱数</p>
            </div>

            <!-- 乗車時間 -->
            <div class="flex flex-col">
                <label for="serviceTime" class="font-medium mb-1 text-gray-600">乗車にかかる時間 (秒)</label>
                <input type="number" id="serviceTime" value="60" min="10" class="p-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500">
                <p class="text-xs text-gray-400 mt-1">サービス処理にかかる固定時間</p>
            </div>
        </div>

        <!-- シミュレーション速度コントロールを500倍速に更新 -->
        <div class="mt-6 pt-4 border-t border-gray-200">
            <label for="simulationSpeed" class="font-medium mb-1 text-gray-600 block">シミュレーション速度: <span id="speedValue" class="font-bold text-red-500">10</span> 倍速 (最大500倍速)</label>
            <input type="range" id="simulationSpeed" min="1" max="500" step="1" value="10" class="speed-slider w-full h-2 bg-red-100 rounded-lg appearance-none cursor-pointer">
            <p class="text-xs text-gray-400 mt-1">左にスライドするとゆっくり、右にスライドすると速くシミュレーションが進行します。</p>
        </div>

        <div class="flex justify-end mt-6">
            <button id="startButton" class="px-6 py-2 bg-emerald-500 text-white font-semibold rounded-lg shadow-md hover:bg-emerald-600 transition duration-150">
                シミュレーション開始 (<span id="startCount">500</span>人)
            </button>
            <button id="resetButton" class="ml-4 px-6 py-2 bg-gray-500 text-white font-semibold rounded-lg shadow-md hover:bg-gray-600 transition duration-150" disabled>
                リセット
            </button>
        </div>
    </div>

    <!-- 視覚化カード -->
    <div class="visualization-card">
        <h2 id="modelTitle" class="text-xl font-semibold mb-4 text-gray-700">乗り場 1つモデル</h2>

        <!-- シミュレーション表示エリア -->
        <div class="simulation-area">
            
            <!-- 乗り場コンテナ -->
            <div id="servicePointContainer" class="service-point-container">
                <!-- 乗り場はJSで動的に追加される -->
            </div>
            
            <!-- 待ち行列フローコンテナ (乗り場と客の動きを包含) -->
            <div class="queue-flow-container">
                <!-- 乗車待機エリア (黄色い点線) -->
                <div class="queue-entrance"></div>
                
                <!-- 待ち行列ライン (客がここに並ぶ) -->
                <div id="queueLine" class="queue-line">
                    <!-- 客はJSで動的に追加・移動する -->
                </div>
            </div>

        </div>

        <!-- 状態表示 -->
        <div class="status-bar">
            <div id="currentTimeDisplayWrapper">
                <span id="currentTimeLabel">現在時刻 (秒)</span>
                <span id="currentTime" class="font-bold text-blue-600">0.00</span>
            </div>
            <div>
                <div>到着客数:</div> 
                <span id="arrivedCount" class="font-bold text-blue-600">0</span>
            </div>
            <div>
                <div>乗車完了:</div> 
                <span id="completedCount" class="font-bold text-blue-600">0</span>
            </div>
            <div>
                <div>平均待ち時間:</div> 
                <span id="avgWaitingTime" class="font-bold text-blue-600">0.00</span>
            </div>
        </div>

        <div id="messageBox" class="absolute inset-0 bg-white/90 backdrop-blur-sm flex items-center justify-center hidden">
            <div class="bg-blue-100 border-l-4 border-blue-500 text-blue-700 p-4 rounded-lg shadow-xl" role="alert">
                <p class="font-bold text-lg">シミュレーションが完了しました！</p>
                <p>最終的な平均待ち時間: <span id="finalAvgWaitTime" class="font-extrabold text-xl"></span> 秒</p>
                <button onclick="document.getElementById('messageBox').classList.add('hidden')" class="mt-4 px-4 py-1 bg-blue-500 text-white text-sm rounded hover:bg-blue-600">閉じる</button>
            </div>
        </div>

    </div>
    
    <!-- 待ち時間一覧表示用コンテナ -->
    <div id="waitingTimesListContainer">
        <h3 class="font-semibold text-gray-700 mb-2">完了客の待ち時間一覧 (全<span id="listTotalCount">500</span>人中 <span id="listCompletedCount">0</span>人)</h3>
        <div id="waitingTimesList" class="divide-y divide-gray-200">
            <p id="listPlaceholder" class="text-gray-500 text-sm">シミュレーション開始後、完了した客の待ち時間がここに表示されます。</p>
        </div>
    </div>
    
</div>

<script>
    // 定数
    const SIM_COUNT = 500; // シミュレーション対象の客数
    const VISUAL_SCALE_X = 55; // キュー内の客の間隔 (客サイズ + 10px)
    const ZERO_THRESHOLD = 0.01; // 待ち時間ゼロ判定のしきい値

    // DOM要素
    const servicePointsSelect = document.getElementById('servicePoints');
    const maxArrivalIntervalInput = document.getElementById('maxArrivalInterval');
    const serviceTimeInput = document.getElementById('serviceTime');
    const startButton = document.getElementById('startButton');
    const resetButton = document.getElementById('resetButton');
    const modelTitle = document.getElementById('modelTitle');
    const servicePointContainer = document.getElementById('servicePointContainer');
    const queueLine = document.getElementById('queueLine');
    const currentTimeDisplay = document.getElementById('currentTime');
    const arrivedCountDisplay = document.getElementById('arrivedCount');
    const completedCountDisplay = document.getElementById('completedCount');
    const avgWaitingTimeDisplay = document.getElementById('avgWaitingTime');
    const messageBox = document.getElementById('messageBox');
    const finalAvgWaitTime = document.getElementById('finalAvgWaitTime');
    const simulationSpeedInput = document.getElementById('simulationSpeed');
    const speedValueDisplay = document.getElementById('speedValue');
    const startCountDisplay = document.getElementById('startCount');
    const listTotalCountDisplay = document.getElementById('listTotalCount');
    const completedCountListDisplay = document.getElementById('listCompletedCount');
    const waitingTimesList = document.getElementById('waitingTimesList');
    const listPlaceholder = document.getElementById('listPlaceholder');

    // シミュレーションの状態変数
    let simState = {
        isRunning: false,
        isPaused: false, 
        timer: null,
        time: 0, // 現在時刻 (秒)
        currentPersonId: 0, // これまでにデータが生成され、システムに登録された客の総数
        maxArrivalInterval: 120, 
        serviceTime: 60, 
        numServicePoints: 1, // 初期値は1
        
        // シミュレーションのコア変数
        touchaku: 0, // 次の客の到着時刻
        servicePointKanryoTimes: [], // 各乗り場の次の完了時刻 
        waitingQueue: [], // 待ち客のリスト (ID)
        
        // 統計情報
        waitingTimes: [], // 全客の待ち時間リスト (生成された客全員分)
        totalWaitingTime: 0,

        // アニメーション用データ
        // { ID: { element, arrivalTime, waitingTime, state, servicePointIndex, queueStartTime, kaishi, kanryo } }
        people: new Map(), 
        animationInterval: 50, // アニメーションの更新間隔 (ms)
        simSpeed: 10, // シミュレーション速度 (デフォルト10倍)
    };

    /**
     * 指定されたIDの客のDOM要素を作成し、キューに追加
     * @param {number} id 客のID (0から始まる到着順)
     * @returns {HTMLElement} 作成されたDOM要素
     */
    function createPersonElement(id) {
        const personEl = document.createElement('div');
        personEl.id = `person-${id}`;
        personEl.className = 'person'; // 初期は opacity: 0 で非表示
        
        // 客の番号とリアルタイム待ち時間表示用の要素を挿入 (ID+1で1からナンバリング)
        personEl.innerHTML = `
            <span class="person-id">${id + 1}</span>
            <div class="person-info">
                <span class="wait-time text-gray-700">0.0秒経過</span>
            </div>
        `;
        
        // 待ち行列の末尾の位置に即座に配置する 
        const queueLength = simState.waitingQueue.length;
        const initialX = queueLength * VISUAL_SCALE_X; 
        
        personEl.style.transform = `translateX(${initialX}px) translateY(-50%)`;
        personEl.style.opacity = 0; // ★修正点: 初期は透明で非表示

        queueLine.appendChild(personEl);

        return personEl;
    }

    /**
     * 乗り場（サービスポイント）のDOM要素を作成・更新
     */
    function updateServicePointsUI() {
        servicePointContainer.innerHTML = '';
        simState.servicePointKanryoTimes = Array(simState.numServicePoints).fill(0);

        for (let i = 0; i < simState.numServicePoints; i++) {
            const spWrapEl = document.createElement('div');
            spWrapEl.className = 'service-point-wrap';
            
            const spEl = document.createElement('div');
            spEl.id = `service-point-${i}`;
            spEl.className = 'service-point';
            spEl.innerHTML = `
                <div class="gauge-area">
                    <div class="text-xs text-white/80 mb-1">乗車時間ゲージ</div>
                    <div class="progress-bar"></div>
                </div>
                <p class="text-lg mt-4">乗り場 ${i + 1}</p>
                <p id="sp-status-${i}" class="text-sm font-normal"></p>
                <!-- サービスポイント内での客の表示 -->
                <div id="sp-person-container-${i}" class="sp-person-container hidden">
                    <div class="sp-person-number"></div>
                    <div class="sp-wait-time"></div>
                </div>
            `;
            spWrapEl.appendChild(spEl);
            servicePointContainer.appendChild(spWrapEl);
        }
    }

    /**
     * 状態をリセットし、UIを初期状態に戻す
     */
    function resetSimulation() {
        clearInterval(simState.timer);
        simState.isRunning = false;
        simState.isPaused = false;
        
        simState.time = 0;
        simState.currentPersonId = 0;
        simState.touchaku = 0;
        simState.waitingQueue = [];
        simState.waitingTimes = [];
        simState.totalWaitingTime = 0;
        simState.people.clear();
        
        queueLine.innerHTML = ''; 
        
        updateServicePointsUI();

        updateStatusDisplay();
        
        completedCountDisplay.textContent = '0'; 

        waitingTimesList.innerHTML = '';
        listPlaceholder.classList.remove('hidden'); // リセット時は表示
        listTotalCountDisplay.textContent = SIM_COUNT; 
        completedCountListDisplay.textContent = '0';
        waitingTimesList.appendChild(listPlaceholder);


        startCountDisplay.textContent = SIM_COUNT;
        startButton.textContent = `シミュレーション開始 (${SIM_COUNT}人)`;
        startButton.classList.remove('bg-yellow-500', 'hover:bg-yellow-600', 'bg-blue-500', 'hover:bg-blue-600');
        startButton.classList.add('bg-emerald-500', 'hover:bg-emerald-600');
        startButton.disabled = false;
        resetButton.disabled = true;
        
        modelTitle.textContent = simState.numServicePoints === 1 
            ? '乗り場 1つモデル' 
            : '乗り場 2つモデル';
    }

    /**
     * シミュレーションの一時停止/再開
     */
    function togglePause() {
        if (!simState.isRunning) return;

        simState.isPaused = !simState.isPaused;

        if (simState.isPaused) {
            clearInterval(simState.timer);
            startButton.textContent = '再開';
            startButton.classList.remove('bg-yellow-500', 'hover:bg-yellow-600');
            startButton.classList.add('bg-blue-500', 'hover:bg-blue-600');
        } else {
            startButton.textContent = '一時停止';
            startButton.classList.remove('bg-blue-500', 'hover:bg-blue-600');
            startButton.classList.add('bg-yellow-500', 'hover:bg-yellow-600');
            simState.timer = setInterval(animationLoop, simState.animationInterval);
        }
    }

    /**
     * シミュレーションのコアロジック (1人分の処理)
     */
    function processNextPerson() {
        const currentId = simState.currentPersonId;
        
        // 1. 到着時刻の計算 (touchaku)
        let tmp = 0;
        if (currentId > 0) {
            const maxInterval = simState.maxArrivalInterval;
            // 乱数生成を1〜maxIntervalの整数に修正
            tmp = 1 + Math.floor(maxInterval * Math.random());
        }
        
        simState.touchaku = simState.touchaku + tmp;
        
        // 2. どの乗り場が最も早く空くかを探す
        let minKanryoTime = Infinity; 
        let spIndex = -1;
        
        for (let i = 0; i < simState.servicePointKanryoTimes.length; i++) {
            if (simState.servicePointKanryoTimes[i] < minKanryoTime) { 
                minKanryoTime = simState.servicePointKanryoTimes[i];
                spIndex = i;
            }
        }
        
        let kaishi = 0; // 乗車開始時刻
        
        // 3. 乗車開始時刻の計算 (kaishi)
        if (simState.touchaku >= minKanryoTime) { 
            // 待ち時間が発生しない場合 (touchaku >= kanryo)
            kaishi = simState.touchaku;
        } else {
            // 待ち時間が発生する場合 (touchaku < kanryo)
            kaishi = minKanryoTime;
        }
        
        // 4. 待ち時間の計算
        const waitingTime = kaishi - simState.touchaku; 
        
        // 5. 乗車完了時刻の更新 (kanryo)
        const kanryo = kaishi + simState.serviceTime;
        simState.servicePointKanryoTimes[spIndex] = kanryo; 

        // 6. 待ち開始時刻 (queueStartTime) の決定
        const queueStartTime = simState.touchaku; // 到着時間

        // 客の到着情報を記録
        const personData = {
            id: currentId,
            element: null, 
            arrivalTime: simState.touchaku, // touchaku
            waitingTime: waitingTime, // 客が待つべき総時間 (統計用)
            state: 'arrived', // 'arrived', 'waiting', 'serving', 'completed'
            servicePointIndex: spIndex, // 割り当てられた乗り場
            queueStartTime: queueStartTime, // ★待ち時間カウントアップの開始時刻
            kaishi: kaishi, // 乗車開始予定時刻
            kanryo: kanryo,
        };
        
        simState.totalWaitingTime += waitingTime;
        simState.waitingTimes.push(waitingTime);
        simState.people.set(currentId, personData);

        // 客のDOM要素を生成し、キューに追加
        personData.element = createPersonElement(currentId);
        simState.waitingQueue.push(currentId);
        
        // 新しい客が追加されたことによる、既存客の位置更新
        updateWaitingQueuePosition();
        
        // 次の客に進む
        simState.currentPersonId++;
    }
    
    /**
     * 待ち客の見た目の位置を更新
     */
    function updateWaitingQueuePosition() {
        // 現在、実際に列に並んでいる客（opacity: 1の客）のみを抽出
        const visibleQueue = simState.waitingQueue.filter(personId => {
            const data = simState.people.get(personId);
            return data && data.element && data.element.style.opacity == 1;
        });

        // visibleQueue の順番に基づいて位置を決定
        visibleQueue.forEach((personId, index) => {
            const data = simState.people.get(personId);
            if (data && data.element) {
                // index * VISUAL_SCALE_X の位置に移動
                const finalX = index * VISUAL_SCALE_X;
                data.element.style.transform = `translateX(${finalX}px) translateY(-50%)`;
            }
        });
    }

    /**
     * 待ち時間一覧を更新する
     * @param {number} id 客のID
     * @param {number} waitingTime 待ち時間
     */
    function updateWaitingList(id, waitingTime) {
        listPlaceholder.classList.add('hidden');
        completedCountListDisplay.textContent = parseInt(completedCountListDisplay.textContent) + 1;

        const listItem = document.createElement('div');
        listItem.className = 'wait-list-item';
        
        const waitText = waitingTime <= ZERO_THRESHOLD ? '待ちなし' : `${waitingTime.toFixed(2)}秒待ち`;
        // サービス時間の2倍を超えると長すぎると判断
        const waitClass = waitingTime > simState.serviceTime * 2 ? 'text-red-500' : (waitingTime > ZERO_THRESHOLD ? 'text-green-600' : 'text-gray-500');

        listItem.innerHTML = `
            <span class="wait-list-label">客 #${id + 1}</span>
            <span class="wait-list-value ${waitClass}">${waitText}</span>
        `;
        
        // リストの先頭に追加
        if (waitingTimesList.firstChild) {
            // プレースホルダーがある場合は先に削除
            if(waitingTimesList.firstChild.id === 'listPlaceholder') {
                waitingTimesList.removeChild(listPlaceholder);
            }
            waitingTimesList.insertBefore(listItem, waitingTimesList.firstChild);
        } else {
            waitingTimesList.appendChild(listItem);
        }
    }


    /**
     * アニメーションの更新とコアロジックの呼び出し
     */
    function animationLoop() {
        if (!simState.isRunning || simState.isPaused) {
            return;
        }

        // 時間の進行 (速度倍率を適用)
        const timeDelta = simState.simSpeed * (simState.animationInterval / 1000); 
        simState.time += timeDelta;

        // 次の客の到着処理 (到着時刻が現在時刻を過ぎていれば次の客のイベントを予約する)
        while (simState.currentPersonId < SIM_COUNT && simState.time >= simState.touchaku) {
             processNextPerson();
        }

        // 客の状態更新とアニメーション
        [...simState.people.values()].forEach((personData) => {
            let { id, element, state, kaishi, kanryo, servicePointIndex, waitingTime, queueStartTime } = personData;
            
            if (!element) return; // DOM要素がなければスキップ
            
            // 1. 待ち客の状態更新 ('arrived' -> 'waiting' または 'serving')
            if (state === 'arrived' || state === 'waiting') {
                const waitTimeEl = element.querySelector('.wait-time');
                
                // ★修正点: リアルタイム経過待ち時間の計算 (現在時刻 - 待ち開始時刻)
                const elapsedTime = Math.max(0, simState.time - queueStartTime);
                
                // 待ち時間が0.01秒を超えたら視覚的に表示を開始する
                if (elapsedTime > ZERO_THRESHOLD) {
                    element.style.opacity = 1;
                    element.classList.add('waiting');
                    personData.state = 'waiting'; // 状態を 'waiting' に更新
                    
                    // 客が表示されたことで列が詰まる可能性があるため、位置を更新
                    updateWaitingQueuePosition(); 
                }
                
                if (waitTimeEl && element.style.opacity == 1) {
                    // ★修正点: リアルタイムの経過時間を表示
                    waitTimeEl.textContent = `${elapsedTime.toFixed(1)}秒経過`; 
                    
                    // 色付けロジック (長い待ち時間には警告色)
                    waitTimeEl.classList.remove('text-gray-700', 'text-red-500', 'text-green-600'); 
                    
                    if (waitingTime > simState.serviceTime * 2) {
                         waitTimeEl.classList.add('text-red-500'); // 長い待ち時間
                    } else if (waitingTime > ZERO_THRESHOLD) {
                         waitTimeEl.classList.add('text-green-600'); // 標準の待ち時間
                    } else {
                         waitTimeEl.classList.add('text-gray-700'); // 待ち時間なし
                    }
                }

                // 待ち行列からのサービスインの処理 (kaishi時刻に達したらサービスイン)
                if (simState.waitingQueue[0] === id && simState.time >= kaishi) {
                    
                    personData.state = 'serving';
                    
                    element.remove(); // キューから要素を削除
                    
                    simState.waitingQueue.shift();
                    updateWaitingQueuePosition();
                    
                    // サービスポイント内に客を表示
                    const spContainerEl = document.getElementById(`sp-person-container-${servicePointIndex}`);
                    if (spContainerEl) {
                        spContainerEl.classList.remove('hidden');
                        
                        const spPersonNumEl = spContainerEl.querySelector('.sp-person-number');
                        if (spPersonNumEl) {
                            spPersonNumEl.textContent = id + 1; 
                        }
                        
                        const spWaitTimeEl = spContainerEl.querySelector('.sp-wait-time');
                        if (spWaitTimeEl) {
                            // ★修正点: 乗り場の下には「待ち時間」を表示
                            const waitDisplay = waitingTime <= ZERO_THRESHOLD ? '待ちなし' : `${waitingTime.toFixed(1)}秒待ち`;
                            spWaitTimeEl.textContent = waitDisplay;

                            spWaitTimeEl.classList.remove('text-white', 'text-yellow-400');
                            if (waitingTime > simState.serviceTime * 2) {
                                spWaitTimeEl.classList.add('text-yellow-400'); // 長い待ち時間警告
                            } else {
                                spWaitTimeEl.classList.add('text-white');
                            }
                        }
                    }
                }
            }
            
            // 2. サービス中 (serving) -> 完了
            if (state === 'serving') {
                const spEl = document.getElementById(`service-point-${servicePointIndex}`);
                const progressBar = spEl ? spEl.querySelector('.progress-bar') : null;
                const spContainerEl = spEl ? spEl.querySelector(`#sp-person-container-${servicePointIndex}`) : null;

                // プログレスバー（乗車時間ゲージ）の更新
                if (progressBar) {
                    const duration = kanryo - kaishi; 
                    const elapsed = simState.time - kaishi; 
                    const progress = Math.min(100, (Math.max(0, elapsed) / duration) * 100);
                    progressBar.style.width = `${progress}%`;
                }
                
                // ★乗車中の表示は更新不要 (サービスイン時にセットした待ち時間を維持)
                // ただし、乗車中に完了客がさらに出た場合、次の客をサービスインさせるまでこの客が表示される
                

                if (simState.time >= kanryo) {
                    personData.state = 'completed';
                    
                    if (spContainerEl) {
                         spContainerEl.classList.add('hidden');
                    }
                    if (progressBar) progressBar.style.width = '0%'; 
                    
                    completedCountDisplay.textContent = parseInt(completedCountDisplay.textContent) + 1;
                    
                    updateWaitingList(id, waitingTime); 
                    
                    simState.people.delete(id);
                    
                    if (parseInt(completedCountDisplay.textContent) === SIM_COUNT) {
                        endSimulation();
                    }
                }
            }
        });

        // 状態表示の更新
        updateStatusDisplay();
    }
    
    /**
     * 状態表示を更新する
     */
    function updateStatusDisplay() {
        // 完了客数に基づいた平均待ち時間を計算
        const completedCount = parseInt(completedCountDisplay.textContent);
        const avgWait = completedCount > 0 
            ? simState.waitingTimes.slice(0, completedCount).reduce((a, b) => a + b, 0) / completedCount
            : 0;

        const displayedArrivedCount = Math.min(SIM_COUNT, simState.currentPersonId);

        currentTimeDisplay.textContent = simState.time.toFixed(2);
        arrivedCountDisplay.textContent = displayedArrivedCount; 
        avgWaitingTimeDisplay.textContent = avgWait.toFixed(2);
        
        // 乗り場の状態を更新
        simState.servicePointKanryoTimes.forEach((kanryoTime, index) => {
            const spEl = document.getElementById(`service-point-${index}`);
            const spStatusEl = document.getElementById(`sp-status-${index}`);
            
            if (spEl) {
                const isBusy = simState.time < kanryoTime;
                
                spEl.style.backgroundColor = isBusy ? '#EF4444' : '#10B981'; // 忙しい:赤, 空き:緑

                if (spStatusEl) {
                    spStatusEl.textContent = isBusy 
                        ? `乗車中`
                        : `待機中 (空き)`;
                }
            }
        });
    }

    /**
     * シミュレーション終了時の処理
     */
    function endSimulation() {
        simState.isRunning = false;
        clearInterval(simState.timer);
        startButton.disabled = true;
        
        const completedCount = parseInt(completedCountDisplay.textContent);
        const avgWait = completedCount > 0 
            ? simState.waitingTimes.slice(0, completedCount).reduce((a, b) => a + b, 0) / completedCount
            : 0;

        finalAvgWaitTime.textContent = avgWait.toFixed(2);
        messageBox.classList.remove('hidden');

        simState.servicePointKanryoTimes.forEach((_, index) => {
            const spEl = document.getElementById(`service-point-${index}`);
            const spStatusEl = document.getElementById(`sp-status-${index}`);
            const spContainerEl = document.getElementById(`sp-person-container-${index}`);
            
            if (spEl) {
                spEl.style.backgroundColor = '#3B82F6';
            }
            if (spStatusEl) {
                 spStatusEl.textContent = `待機中`; 
            }
            if (spContainerEl) {
                spContainerEl.classList.add('hidden');
            }
        });
    }
    
    // --- イベントリスナー ---

    // 設定変更時の処理
    servicePointsSelect.addEventListener('change', () => {
        if (simState.isRunning) {
            console.error('シミュレーションをリセットしてから設定を変更してください。');
            servicePointsSelect.value = simState.numServicePoints;
            return;
        }
        simState.numServicePoints = parseInt(servicePointsSelect.value);
        resetSimulation();
    });

    // シミュレーション速度スライダーのイベントリスナー
    simulationSpeedInput.addEventListener('input', () => {
        const newSpeed = parseFloat(simulationSpeedInput.value);
        simState.simSpeed = newSpeed;
        speedValueDisplay.textContent = newSpeed.toFixed(0); 
    });

    // シミュレーション開始/一時停止/再開 ボタン
    startButton.addEventListener('click', () => {
        if (!simState.isRunning) {
            
            simState.numServicePoints = parseInt(servicePointsSelect.value);
            simState.maxArrivalInterval = parseInt(maxArrivalIntervalInput.value);
            simState.serviceTime = parseInt(serviceTimeInput.value);
            
            resetSimulation(); 

            simState.isRunning = true;
            simState.isPaused = false;
            
            simState.touchaku = 0; 
            processNextPerson();

            startButton.textContent = '一時停止';
            startButton.classList.remove('bg-emerald-500', 'hover:bg-emerald-600');
            startButton.classList.add('bg-yellow-500', 'hover:bg-yellow-600');
            resetButton.disabled = false;
            
            simState.timer = setInterval(animationLoop, simState.animationInterval);
            
        } else {
            togglePause();
        }
    });

    // リセットボタン
    resetButton.addEventListener('click', resetSimulation);
    
    // 初期ロード時の処理
    window.onload = () => {
        const initialSpeed = parseInt(simulationSpeedInput.value);
        simState.simSpeed = initialSpeed;
        speedValueDisplay.textContent = initialSpeed.toFixed(0);

        resetSimulation(); 
    };
</script>

</body>
</html>
